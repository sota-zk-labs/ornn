module verifier_addr::cpu_constraint_poly {

    use std::vector;
    use std::vector::{push_back, borrow};

    const PRIME: u256 = 0x800000000000011000000000000000000000000000000000000000000000001;

    public fun fmul(a: u256, b: u256): u256 {
        0
    }

    public fun fexp(a: u256, b: u256): u256 {
        0
    }

    public fun fallback(ctx: &vector<u256>): u256 {
        let ctx = *ctx;
        let res = 0;

        let remain = 404 - vector::length(&ctx);

        for (i in 0..remain) {
            vector::push_back(&mut ctx, 0);
        };

        {
            // compute expmods
            {{ expmods }}
        };

        {
            // compute domains
            {{ domains }}

        };

        {
            // compute denominators
            {{ denominators }}
        };

        {
            // compute denominator_invs


        };

        let composition_alpha_pow = 1u256;

        let composition_alpha = /*composition_alpha*/ *borrow(&ctx, 41);

        {
            // compute compositions
             {{ compositions }}
        };
        res
    }
}
